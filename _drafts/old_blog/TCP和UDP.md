## TCP和UDP
1. tcp中为什么是三次握手，而不是2次握手或者更多？

为了防止已失效的连接请求报文段有传送到B，因而产生错误。
网络传输过程中是不可靠的，可能会出现数据拥塞，导致延时或者丢包，此时，在网络中可能会存在大量的重传报文，客户端发起一个tcp连接请求报文在网络滞留时间过长时，会重新发送一个新的tcp请求，数据在这个请求中已经处理结束，服务端才收到前一个请求报文，这时这个报文作为一个失效报文，客户端不会进行处理，而服务端却为这个报文建立了一个新的连接，一直等待客户端发送报文，导致资源浪费

2. tcp的三次握手和四次挥手

**三次握手**

客户端发起tcp请求，发送一个请求报文，携带一个初始序号sequence，报文中syn标志位置1，进入syn_send状态，等待服务器确认

服务端收到请求报文，发送一个确认报文，携带一个初始序号sequence，同时携带序号acknowledge=客户端sequence+1，报文中syn和ack标志位均置1，服务器由listen状态转为syn_recv状态

客户端收到服务端的报文，发送一个确认报文，sequence+1，报文中ack标志位置1，客户端转为established，服务端收到报文转为established

**四次挥手**

因为tcp是全双工的，数据在两个方向上传输，因此需要两个方向进行关闭，连接的终止可以由任意一端发起。

假设客户端发起关闭：

发送一个终止报文，报文中fin标志位置1，假设sequence为1521，acknowledge为805，客户端进行fin_wait_1状态

服务端收到报文，发送一个确认报文，报文中ack标志置1，sequence为805，acknowledge为1522，服务端进入closed_wait状态，客户端收到报文，转为fin_wait_2状态

*此时服务端如果还有数据传送，则继续发送数据，客户端依然会接受，等待数据发送完毕后，发送终止报文*

服务端发送终止报文，报文中fin标志置1，sequence为805，acknowledge为1522，进入last_ack状态

客户端收到报文，发送一个确认报文，报文中ack标志置1，sequence为1522，acknowledge为806，进入time_wait状态，服务端收到报文，转为closed状态

客户端等到2MSL时间后，进入closed状态

3. 主动关闭的一方为什么要等待2MSL时间？

MSL为报文最大生存时间，一般指的是报文从客户端发送到服务端的一个大致时间，会不断更新，2MSL即如果确认报文丢失，则正好能够收到服务端发送过来的重传报文的时间，这样便可以保证*服务端能够正常关闭*。

4. tcp中的重传机制

**超时重传**

RTT：一个数据报文在网络中的往返时间（报文发送到收到确认的时间）

RTO：超时重传时间

RTO通常会在RTT的基础上通过一个算法来得到，会比RTT大一些

**快速重传**

不以时间为标准，以数据为标准来进行重传

例如在连续发送5个报文出去后，假设2号报文丢失，在3,4,5号报文到达时，均会发送ack=2的确认报文，这样在收到连续的3个相同的ack报文时，会触发快速重传，重传2号报文

**sack**

通过这TCP首部中添加字段sack，接受方将最近已接收的报文段序号写进去，发送方可以通过该字段确认需要重传的报文段。

eg： 
S -- 100-199 -- R 发送100-199的报文

S -- 200-299 -- R 丢失

S -- 300-399 -- R 回ACK=200 SACK=300-400

S -- 400-499 -- R 回ACK=200 SACK=300-500

S -- 500-599 -- R 回ACK=200 SACK=300-600

触发快速重传机制，发现只有200-299数据丢失，重发200-299

**duplicate sack**
主要用于ack应答报文丢失的情况,发送发超时重传，导致接收端接收到重复报文。

同样写sack字段，ack会比sack序号大，说明sack字段的报文被重复接收。

5. 滑动窗口

**目的**

TCP 引入滑动窗口的最直接的原因是“接收方的缓存是有限的”
- 发送方不能假设接收方缓存无限大，一直发包，造成接收方丢包。
- 发送方不能假设接收方窗口很小，发一会停一会，效率不高，浪费带宽。
- 所以需要发送方随时报告自己的缓存能力（即窗口）给发送方，发送方可以根据此窗口大小来发送一定的数据。

**作用**

- 可靠性：保证数据准确（按序、完整、未出错）到达目的地，如果未到达或数据出错，能够发现并重传。
- 流量控制：管理发送端的数据发送速率，以使接收设备不致于过载。


发送窗口：无需等待确认报文的到来，可以继续发送报文的个数的最大值

窗口的实现即在内存中开辟的一块缓存空间，在未收到确认报文之前，需在其中保留已发送的数据，收到确认报文，确认的部分就可以删除，以报文序号为一条线来看，即窗口向前滑动。

通过滑动窗口可以进行累积确认，一段数据中某一个ack确认报文丢失，只要收到后面的确认报文，即认为这一段数据已收到。

滑动窗口大小一般由接收方决定，发送数据不能大于滑动窗口大小，多于窗口的报文不能被接收。

发送端滑动窗口把报文分为四个部分：
- 已发送且已确认部分，这部分已不再窗口之内
- 已发送未确认部分，还存在与窗口之中
- 未发送部分，存在于窗口之中，可发送
- 未发送且未在窗口之中，不可发送

接收端滑动窗口将报文分为三个部分：
- 已确认部分，不在窗口之中
- 准备接收报文部分 即窗口大小
- 不可接收部分

**流量控制**

目的：避免发送端数据占满接收端缓冲区

在正常情况下，接收端和发送端根据协商通告的窗口大小，发一部分数据，便确认一部分数据，两端的窗口都有节奏的向后滑动，数据良好的进行传输

若接收端应用进程繁忙，不能及时冲缓冲区将收到的部分取走，就会导致接收端缓冲区变小，同时窗口大小不断减小

接收端窗口减小，通告给发送端后，发送端发送数据便逐步减少，直到接收端窗口大小减为0，接收端不在发送数据。

在在接收端窗口大小重新大于0后，会通告发送端继续发送数据。

若接收端窗口大于0的通告报文丢失，为了避免“发送端认为窗口为零停止发包，接收端通告新窗口后等待收包”的僵持情况，在发送端收到窗口为零的消息时，会启动定时器，超时后询问接收端窗口大小，重新进入收发报文过程。

**糊涂窗口综合症**

由于接收窗口较小，导致小包在网络中不停传输的现象。导致发包效率较低，同时影响网络中数据传输

解决办法：

- a 接收端不通告小窗口
取MSS和窗口大小的一半中的较小值，当可用窗口小于这个较小值时，通告窗口为0，停止发包。大于这个较小值后，在通告窗口大小，发送端开始发包。
- b 发送端不发送小报文，采用nagle算法

**nagle算法**

要求一个TCP 连接上最多只能有一个未被确认的小分组被发送

即：
- 前一个小分组被确认，可以发送数据，大小无要求
- 发送数据大于MSS，可以发送

6. 拥塞控制

目的：避免数据填满整个网络

拥塞窗口：
发送方维护一个拥塞窗口，其大小会根据网络的拥塞状态动态变化，一旦发送方发生超时重传，即认为网络出现拥塞。

拥塞窗口中的几种机制：

- a 慢启动

以MSS为单位，TCP刚建立连接时，可以发送的是1个MSS的数据大小
在收到ack确认报文后，拥塞窗口加1，可以发送2个MSS的数据大小
在此收到ack确认报文，拥塞窗口加2，可以发送4个MSS的数据大小……
窗口大小呈指数增长，直到达到慢启动门限（ssthresh），进入拥塞避免，ssthresh通常为65535字节。（cwnd的增加还是以字节的方式增加，因为MSS由协商获得，以MSS为单位更好记忆。）
（对于每一个确认的报文，cwnd加1）
这一阶段的增长速率是指数增加的

- b 拥塞避免

进入拥塞避免，cwnd的增长由指数增长转为线性增长，每次最多cwnd加1，这一阶段的增长速率开始平稳

- c 拥塞发生

1 出现超时重传时：
超时重传时，会认为网络出现一个比较拥堵的状态，这个时候会出现：
Ssthresh减小为cwnd/2，cwnd重置为1，重新进入慢启动状态

2 出现快速重传时：
快速重传时，会认为网络中拥堵状况不严重，丢了部分数据包，此时，进入快速恢复。

- d 快速恢复

当收到第3个重复的ack报文时，将慢启动门限降低为cwnd的一半，同时发送丢失的报文。设置cwnd为ssthresh+3，进入拥塞避免。


7. TCP的粘包和拆包

转自[https://blog.csdn.net/ailunlee/article/details/95944377](https://blog.csdn.net/ailunlee/article/details/95944377)


- 背景

TCP是个“流”协议，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。

（1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；

（2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；

（3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；

（4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。

如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。

- 原因

（1）要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；

（2）接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；

（3）要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；

（4）待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。

- 解决方法

由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：

消息定长。发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。

设置消息边界。服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如FTP协议。

将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。

更复杂的应用层协议。


8. ip层如何区分TCP和UDP报文？

根据协议位（8bit）来区分，tcp是6，udp是17


9. TCP和UDP的区别
- 连接：TCP面向连接，UDP是无连接的
- 可靠性： TCP是可靠交付，而UDP是不可靠的
- 服务对象： TCP是点对点的两点之间的服务，UDP可以一对一，一对多，多对一
- 流量控制： TCP存在流量控制和拥塞控制来保证数据传输，UDP不考虑网络状况
- 报文长度：TCP是动态报文长度，根据窗口大小来定，UDP是面向报文的，不会出现合并，拆分，保留报文边界
- 首部开销：TCP首部20字节，开销大，UDP首部8字节，开销小

10. TCP和UDP的使用场景

TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。
若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）

11. 有哪些基于TCP或者UDP的应用层协议
- TCP: FTP TELNET SSH SMTP（简单邮件传输协议） HTTP
- UDP: DNS TFTP（简单文件传输协议） SNMP（简单网络管理协议） NTP

12. 七层OSI模型

物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit,IEE802.3 CLOCK RJ45
数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧, MAC VLAN PPP
网络层：负责数据包从源到宿的传递和网际互连，传输单位为包, IP ARP ICMP
传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文, TCP UDP
会话层：建立、管理和终止会话，传输单位为SPDU,RPC NFS
表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU,JPEG ASII
应用层: 允许访问OSI环境的手段,传输单位为APDU,FTP HTTP DNS





